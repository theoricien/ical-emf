/*
 * generated by Xtext 2.22.0
 */
package xCalendar.serializer;

import com.google.inject.Inject;
import iCal.AlarmC;
import iCal.Calendar;
import iCal.ComponentAlarmAudioProperty;
import iCal.ComponentAlarmDispProperty;
import iCal.ComponentAlarmEmailProperty;
import iCal.ComponentAlarmTime;
import iCal.DateT;
import iCal.EventC;
import iCal.ICalPackage;
import iCal.JournalC;
import iCal.MonthNameT;
import iCal.MonthT;
import iCal.TimeZoneC;
import iCal.ToDoC;
import iCal.VacationC;
import iCal.iCalFormat;
import iCal.tzprop;
import iCal.tzpropOptional;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xCalendar.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ICalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ICalPackage.ALARM_C:
				sequence_AlarmC(context, (AlarmC) semanticObject); 
				return; 
			case ICalPackage.CALENDAR:
				sequence_Calendar(context, (Calendar) semanticObject); 
				return; 
			case ICalPackage.COMPONENT_ALARM_AUDIO_PROPERTY:
				sequence_ComponentAlarmAudioProperty(context, (ComponentAlarmAudioProperty) semanticObject); 
				return; 
			case ICalPackage.COMPONENT_ALARM_DISP_PROPERTY:
				sequence_ComponentAlarmDispProperty(context, (ComponentAlarmDispProperty) semanticObject); 
				return; 
			case ICalPackage.COMPONENT_ALARM_EMAIL_PROPERTY:
				sequence_ComponentAlarmEmailProperty(context, (ComponentAlarmEmailProperty) semanticObject); 
				return; 
			case ICalPackage.COMPONENT_ALARM_TIME:
				sequence_ComponentAlarmTime(context, (ComponentAlarmTime) semanticObject); 
				return; 
			case ICalPackage.DATE_T:
				sequence_DateT(context, (DateT) semanticObject); 
				return; 
			case ICalPackage.EVENT_C:
				sequence_EventC(context, (EventC) semanticObject); 
				return; 
			case ICalPackage.JOURNAL_C:
				sequence_JournalC(context, (JournalC) semanticObject); 
				return; 
			case ICalPackage.MONTH_NAME_T:
				sequence_MonthNameT(context, (MonthNameT) semanticObject); 
				return; 
			case ICalPackage.MONTH_T:
				sequence_MonthT(context, (MonthT) semanticObject); 
				return; 
			case ICalPackage.TIME_ZONE_C:
				sequence_TimeZoneC(context, (TimeZoneC) semanticObject); 
				return; 
			case ICalPackage.TO_DO_C:
				sequence_ToDoC(context, (ToDoC) semanticObject); 
				return; 
			case ICalPackage.VACATION_C:
				sequence_VacationC(context, (VacationC) semanticObject); 
				return; 
			case ICalPackage.ICAL_FORMAT:
				sequence_iCalFormat(context, (iCalFormat) semanticObject); 
				return; 
			case ICalPackage.TZPROP:
				sequence_tzprop(context, (tzprop) semanticObject); 
				return; 
			case ICalPackage.TZPROP_OPTIONAL:
				sequence_tzpropOptional(context, (tzpropOptional) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Component returns AlarmC
	 *     AlarmC returns AlarmC
	 *
	 * Constraint:
	 *     (
	 *         action=STR | 
	 *         trigger=STR | 
	 *         attach=STR | 
	 *         description=STR | 
	 *         type=AlarmType | 
	 *         time=ComponentAlarmTime
	 *     )+
	 */
	protected void sequence_AlarmC(ISerializationContext context, AlarmC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Calendar returns Calendar
	 *
	 * Constraint:
	 *     (component+=Component component+=Component*)
	 */
	protected void sequence_Calendar(ISerializationContext context, Calendar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlarmType returns ComponentAlarmAudioProperty
	 *     ComponentAlarmAudioProperty returns ComponentAlarmAudioProperty
	 *
	 * Constraint:
	 *     attach=STR?
	 */
	protected void sequence_ComponentAlarmAudioProperty(ISerializationContext context, ComponentAlarmAudioProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlarmType returns ComponentAlarmDispProperty
	 *     ComponentAlarmDispProperty returns ComponentAlarmDispProperty
	 *
	 * Constraint:
	 *     description=STR
	 */
	protected void sequence_ComponentAlarmDispProperty(ISerializationContext context, ComponentAlarmDispProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ICalPackage.Literals.COMPONENT_ALARM_DISP_PROPERTY__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ICalPackage.Literals.COMPONENT_ALARM_DISP_PROPERTY__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentAlarmDispPropertyAccess().getDescriptionSTRTerminalRuleCall_3_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AlarmType returns ComponentAlarmEmailProperty
	 *     ComponentAlarmEmailProperty returns ComponentAlarmEmailProperty
	 *
	 * Constraint:
	 *     ((attendee+=STR attendee+=STR*) | description=STR | (attach+=STR attach+=STR*))+
	 */
	protected void sequence_ComponentAlarmEmailProperty(ISerializationContext context, ComponentAlarmEmailProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentAlarmTime returns ComponentAlarmTime
	 *
	 * Constraint:
	 *     (duration=STR | repeat=STR)*
	 */
	protected void sequence_ComponentAlarmTime(ISerializationContext context, ComponentAlarmTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DateT returns DateT
	 *
	 * Constraint:
	 *     (day_name=DayName? day=INT month=Month year=INT? (hours=INT minutes=INT? seconds=INT?)?)
	 */
	protected void sequence_DateT(ISerializationContext context, DateT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns EventC
	 *     EventC returns EventC
	 *
	 * Constraint:
	 *     (
	 *         dtstart=DateT | 
	 *         uid=STR | 
	 *         organizer=STR | 
	 *         summary=STR | 
	 *         url=STR | 
	 *         (attach+=STR attach+=STR*) | 
	 *         (attendee+=STR attendee+=STR*) | 
	 *         (categories+=STR categories+=STR*) | 
	 *         (comment+=STR comment+=STR*) | 
	 *         (contact+=STR contact+=STR*) | 
	 *         (rstatus+=EventStatus rstatus+=EventStatus*) | 
	 *         (related+=STR related+=STR*) | 
	 *         (resources+=STR resources+=STR*) | 
	 *         description=STR | 
	 *         priority=STR | 
	 *         location=STR | 
	 *         dtend=DateT | 
	 *         class=Classification | 
	 *         (alarmc+=AlarmC alarmc+=AlarmC*)
	 *     )+
	 */
	protected void sequence_EventC(ISerializationContext context, EventC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns JournalC
	 *     JournalC returns JournalC
	 *
	 * Constraint:
	 *     (
	 *         uid=STR | 
	 *         dtstart=DateT | 
	 *         class=Classification | 
	 *         created=STR | 
	 *         last_mod=STR | 
	 *         organizer=STR | 
	 *         seq=STR | 
	 *         status=STR | 
	 *         summary=STR | 
	 *         url=STR | 
	 *         recurid=STR | 
	 *         (rrule+=STR rrule+=STR*) | 
	 *         (attach+=STR attach+=STR*) | 
	 *         (attendee+=STR attendee+=STR*) | 
	 *         (categories+=STR categories+=STR*) | 
	 *         (comment+=STR comment+=STR*) | 
	 *         (contact+=STR contact+=STR*) | 
	 *         (exdate+=STR exdate+=STR*) | 
	 *         (rstatus+=STR rstatus+=STR*) | 
	 *         (related+=STR related+=STR*) | 
	 *         (resources+=STR resources+=STR*) | 
	 *         (rdate+=STR rdate+=STR*) | 
	 *         (x_prop+=STR x_prop+=STR*) | 
	 *         (iana_prop+=STR iana_prop+=STR*) | 
	 *         description=STR
	 *     )+
	 */
	protected void sequence_JournalC(ISerializationContext context, JournalC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Month returns MonthNameT
	 *     MonthNameT returns MonthNameT
	 *
	 * Constraint:
	 *     (
	 *         value='Janvier' | 
	 *         value='Fevrier' | 
	 *         value='Mars' | 
	 *         value='Avril' | 
	 *         value='Mai' | 
	 *         value='Juin' | 
	 *         value='Juillet' | 
	 *         value='Aout' | 
	 *         value='Septembre' | 
	 *         value='Octobre' | 
	 *         value='Novembre' | 
	 *         value='Decembre'
	 *     )
	 */
	protected void sequence_MonthNameT(ISerializationContext context, MonthNameT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Month returns MonthT
	 *     MonthT returns MonthT
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_MonthT(ISerializationContext context, MonthT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ICalPackage.Literals.MONTH_T__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ICalPackage.Literals.MONTH_T__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMonthTAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns TimeZoneC
	 *     TimeZoneC returns TimeZoneC
	 *
	 * Constraint:
	 *     (
	 *         tzid=STR | 
	 *         last_mod=STR | 
	 *         tzurl=STR | 
	 *         (x_prop+=STR x_prop+=STR*) | 
	 *         (iana_prop+=STR iana_prop+=STR*) | 
	 *         (standardc+=tzprop standardc+=tzprop*) | 
	 *         (daylightc+=tzprop daylightc+=tzprop*)
	 *     )+
	 */
	protected void sequence_TimeZoneC(ISerializationContext context, TimeZoneC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns ToDoC
	 *     ToDoC returns ToDoC
	 *
	 * Constraint:
	 *     (
	 *         dtstamp=DateT | 
	 *         uid=STR | 
	 *         due=DateT | 
	 *         dtstart=DateT | 
	 *         class=Classification | 
	 *         created=STR | 
	 *         last_mod=STR | 
	 *         organizer=STR | 
	 *         seq=STR | 
	 *         status=STR | 
	 *         summary=STR | 
	 *         url=STR | 
	 *         recurid=STR | 
	 *         (rrule+=STR rrule+=STR*) | 
	 *         (attach+=STR attach+=STR*) | 
	 *         (attendee+=STR attendee+=STR*) | 
	 *         (categories+=STR categories+=STR*) | 
	 *         (comment+=STR comment+=STR*) | 
	 *         (contact+=STR contact+=STR*) | 
	 *         (exdate+=STR exdate+=STR*) | 
	 *         (rstatus+=STR rstatus+=STR*) | 
	 *         (related+=STR related+=STR*) | 
	 *         (resources+=STR resources+=STR*) | 
	 *         (rdate+=STR rdate+=STR*) | 
	 *         (x_prop+=STR x_prop+=STR*) | 
	 *         (iana_prop+=STR iana_prop+=STR*) | 
	 *         description=STR | 
	 *         completed=STR | 
	 *         priority=STR | 
	 *         geo=STR | 
	 *         location=STR | 
	 *         (alarmc+=AlarmC alarmc+=AlarmC*)
	 *     )+
	 */
	protected void sequence_ToDoC(ISerializationContext context, ToDoC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns VacationC
	 *     VacationC returns VacationC
	 *
	 * Constraint:
	 *     (
	 *         uid=STR | 
	 *         dtstart=DateT | 
	 *         organizer=STR | 
	 *         url=STR | 
	 *         contact=STR | 
	 *         dtend=DateT | 
	 *         (attendee+=STR attendee+=STR*) | 
	 *         (comment+=STR comment+=STR*) | 
	 *         (freebusy+=STR freebusy+=STR*) | 
	 *         (rstatus+=STR rstatus+=STR*) | 
	 *         (x_prop+=STR x_prop+=STR*) | 
	 *         (iana_prop+=STR iana_prop+=STR*)
	 *     )+
	 */
	protected void sequence_VacationC(ISerializationContext context, VacationC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     iCalFormat returns iCalFormat
	 *
	 * Constraint:
	 *     (fileName=STR calendar=Calendar)
	 */
	protected void sequence_iCalFormat(ISerializationContext context, iCalFormat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ICalPackage.Literals.ICAL_FORMAT__FILE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ICalPackage.Literals.ICAL_FORMAT__FILE_NAME));
			if (transientValues.isValueTransient(semanticObject, ICalPackage.Literals.ICAL_FORMAT__CALENDAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ICalPackage.Literals.ICAL_FORMAT__CALENDAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getICalFormatAccess().getFileNameSTRTerminalRuleCall_1_0(), semanticObject.getFileName());
		feeder.accept(grammarAccess.getICalFormatAccess().getCalendarCalendarParserRuleCall_2_0(), semanticObject.getCalendar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     tzpropOptional returns tzpropOptional
	 *
	 * Constraint:
	 *     (comment=STR | rdate=STR | tzname=STR | x_prop=STR | iana_prop=STR)*
	 */
	protected void sequence_tzpropOptional(ISerializationContext context, tzpropOptional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     tzprop returns tzprop
	 *
	 * Constraint:
	 *     (dtstart=STR | tzoffseto=STR | tzoffsetfrom=STR | rrule=STR | (opt+=tzpropOptional opt+=tzpropOptional*))+
	 */
	protected void sequence_tzprop(ISerializationContext context, tzprop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
